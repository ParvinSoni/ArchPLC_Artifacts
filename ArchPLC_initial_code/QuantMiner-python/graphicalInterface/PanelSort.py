import math

#                                             
# *Copyright 2007, 2011 CCLS Columbia University (USA), LIFO University of Orl��ans (France), BRGM (France)
# *
# *Authors: Cyril Nortet, Xiangrong Kong, Ansaf Salleb-Aouissi, Christel Vrain, Daniel Cassard
# *
# *This file is part of QuantMiner.
# *
# *QuantMiner is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.
# *
# *QuantMiner is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
# *
# *You should have received a copy of the GNU General Public License along with QuantMiner.  If not, see <http://www.gnu.org/licenses/>.
# 



from src.apriori import *
from src.database import *
from src.graphicalInterface.TreeTable import *
from src.solver import *
from src.tools import *


class PanelSort(javax.swing.JPanel):

    METHODE_TRI_SUPPORT = 0
    METHODE_TRI_CONFIANCE = 1
    METHODE_TRI_NOMBRE_ATTRIBUTS = 2

    #* Creates new form PanneauTri 
    def __init__(self, panneauResultats, contexteResolution):
        self.__jButtonAppliquer = None
        self.__jButtonFiltre = None
        self.__jButtonFiltreSelection = None
        self.__jButtonReinitFiltre = None
        self.__jCheckBoxInteret = None
        self.__jCheckBoxTriDecroissant = None
        self.__jComboBoxMethodeTri = None
        self.__jLabelFiltre = None
        self.__jLabelMethodeTri = None
        self.__jScrollPaneFiltre = None
        self.__jTextFieldInteret = None
        self.__m_panneauResultats = None
        self.__m_contexteResolution = None
        self.__m_bPanneauFiltreAffiche = False

        self.__initComponents()

        self.__jTextFieldInteret.setText(src.solver.ResolutionContext.EcrirePourcentage(0.75f, 3, False))
        self.__jTextFieldInteret.setEnabled(False)
        self.__jCheckBoxInteret.setSelected(False)

        self.__m_panneauResultats = panneauResultats
        self.__m_contexteResolution = contexteResolution
        self.__m_bPanneauFiltreAffiche = False

        self.__InitialiserContenuPanneau()

    #    * This method is called from within the constructor to
    #     * initialize the form.
    #     * WARNING: Do NOT modify this code. The content of this method is
    #     * always regenerated by the Form Editor.
    #     
    # <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    def __initComponents(self):
        self.__jComboBoxMethodeTri = javax.swing.JComboBox() #sorting method
        self.__jLabelMethodeTri = javax.swing.JLabel() #"Sorting method"
        self.__jCheckBoxTriDecroissant = javax.swing.JCheckBox() #descending order check box
        self.__jScrollPaneFiltre = javax.swing.JScrollPane() #filter panel --will open when click browse filter
        self.__jLabelFiltre = javax.swing.JLabel() #label in filter panel --will open when click browse filter
        self.__jButtonAppliquer = javax.swing.JButton() #apply button
        self.__jButtonFiltre = javax.swing.JButton() #Display filter
        self.__jButtonReinitFiltre = javax.swing.JButton() #reinitialize filter
        self.__jButtonFiltreSelection = javax.swing.JButton() #filter from selection
        self.__jCheckBoxInteret = javax.swing.JCheckBox() #check box of Exclude rules with consequent support exceeds...
        self.__jTextFieldInteret = javax.swing.JTextField() #0.0f-100.0f

        setLayout(None)

        self.__jComboBoxMethodeTri.setModel(javax.swing.DefaultComboBoxModel(["confidence sorting", "support sorting", "sorting by attributes number"]))
        self.__jComboBoxMethodeTri.addActionListener(ActionListenerAnonymousInnerClass(self))

        add(self.__jComboBoxMethodeTri)
        self.__jComboBoxMethodeTri.setBounds(170, 10, 230, 20)

        self.__jLabelMethodeTri.setText("Sorting method :")
        add(self.__jLabelMethodeTri)
        self.__jLabelMethodeTri.setBounds(10, 10, 160, 14)

        self.__jCheckBoxTriDecroissant.setSelected(True)
        self.__jCheckBoxTriDecroissant.setText("decreasing order")
        add(self.__jCheckBoxTriDecroissant)
        self.__jCheckBoxTriDecroissant.setBounds(410, 10, 130, 20)

        #filter panel --will open when click browse filter
        add(self.__jScrollPaneFiltre)
        self.__jScrollPaneFiltre.setBounds(10, 110, 510, 110)

        self.__jLabelFiltre.setText("Filter on items :")
        add(self.__jLabelFiltre)
        self.__jLabelFiltre.setBounds(10, 90, 140, 20)

        self.__jButtonAppliquer.setText("APPLY")
        self.__jButtonAppliquer.addActionListener(ActionListenerAnonymousInnerClass2(self))

        add(self.__jButtonAppliquer)
        self.__jButtonAppliquer.setBounds(540, 10, 130, 70)

        self.__jButtonFiltre.setText("Display filter")
        self.__jButtonFiltre.addActionListener(ActionListenerAnonymousInnerClass3(self))

        add(self.__jButtonFiltre)
        self.__jButtonFiltre.setBounds(10, 60, 140, 20)

        self.__jButtonReinitFiltre.setText("Reinitialize filter")
        self.__jButtonReinitFiltre.addActionListener(ActionListenerAnonymousInnerClass4(self))

        add(self.__jButtonReinitFiltre)
        self.__jButtonReinitFiltre.setBounds(170, 60, 180, 20)

        self.__jButtonFiltreSelection.setText("Filter from selection")
        self.__jButtonFiltreSelection.addActionListener(ActionListenerAnonymousInnerClass5(self))

        add(self.__jButtonFiltreSelection)
        self.__jButtonFiltreSelection.setBounds(370, 60, 237, 20)

        self.__jCheckBoxInteret.setText("Exclude rules with consequent support (part B) exceeds (%) : ")
        self.__jCheckBoxInteret.addActionListener(ActionListenerAnonymousInnerClass6(self))

        add(self.__jCheckBoxInteret)
        self.__jCheckBoxInteret.setBounds(6, 34, 440, 20)

        self.__jTextFieldInteret.setInputVerifier(ToolsInterface.VerifieurTextFieldIntervalleFloat(0.0f, 100.0f))
        add(self.__jTextFieldInteret)
        self.__jTextFieldInteret.setBounds(450, 34, 66, 20)
 # </editor-fold>//GEN-END:initComponents

    class ActionListenerAnonymousInnerClass(java.awt.event.ActionListener):

        def __init__(self, outerInstance):
            self.__outerInstance = outerInstance

        def actionPerformed(self, evt):
            outerInstance.__jComboBoxMethodeTriActionPerformed(evt)

    class ActionListenerAnonymousInnerClass2(java.awt.event.ActionListener):

        def __init__(self, outerInstance):
            self.__outerInstance = outerInstance

        def actionPerformed(self, evt):
            outerInstance.__jButtonAppliquerActionPerformed(evt)

    class ActionListenerAnonymousInnerClass3(java.awt.event.ActionListener):

        def __init__(self, outerInstance):
            self.__outerInstance = outerInstance

        def actionPerformed(self, evt):
            outerInstance.__jButtonFiltreActionPerformed(evt)

    class ActionListenerAnonymousInnerClass4(java.awt.event.ActionListener):

        def __init__(self, outerInstance):
            self.__outerInstance = outerInstance

        def actionPerformed(self, evt):
            outerInstance.__jButtonReinitFiltreActionPerformed(evt)

    class ActionListenerAnonymousInnerClass5(java.awt.event.ActionListener):

        def __init__(self, outerInstance):
            self.__outerInstance = outerInstance

        def actionPerformed(self, evt):
            outerInstance.__jButtonFiltreSelectionActionPerformed(evt)

    class ActionListenerAnonymousInnerClass6(java.awt.event.ActionListener):

        def __init__(self, outerInstance):
            self.__outerInstance = outerInstance

        def actionPerformed(self, evt):
            outerInstance.__jCheckBoxInteretActionPerformed(evt)

    def __jComboBoxMethodeTriActionPerformed(self, evt):
        # Add your handling code here:
        pass #GEN-LAST:event_jComboBoxMethodeTriActionPerformed

    def __jCheckBoxInteretActionPerformed(self, evt):
        if self.__jCheckBoxInteret.isSelected():
            self.__jTextFieldInteret.setEnabled(True)
        else:
            self.__jTextFieldInteret.setEnabled(False) #GEN-LAST:event_jCheckBoxInteretActionPerformed



    def __jButtonFiltreSelectionActionPerformed(self, evt):
        regleCourante = None
        iIndiceCoteRegle = 0
        iTypePriseEnCompte = 0
        iNombreColonnes = 0
        iIndiceColonne = 0
        iTypeNoeud = 0
        sNomColonne = None
        colonneDonnees = None
        gestionnaireBD = None
        tItems = None
        iNombreItems = 0
        iIndiceItem = 0
        item = None
        tItemsRegle = None
        itemQual = None
        itemQuant = None
        sNomItem = None


        regleCourante = self.__m_panneauResultats.ObtenirRegleCourante()
        if regleCourante is None:
            return


        # Pour commencer, on fait en sorte de ne plus rien filtrer :
        if self.__m_contexteResolution is None:
            return

        gestionnaireBD = self.__m_contexteResolution.m_gestionnaireBD
        if gestionnaireBD is None:
            return

        #get the number of columns selected
        iNombreColonnes = gestionnaireBD.ObtenirNombreColonnesPrisesEnCompte()
        if iNombreColonnes == 0:
            return

        iIndiceColonne = 0
        while iIndiceColonne<iNombreColonnes:
            #get a selected column
            colonneDonnees = gestionnaireBD.ObtenirColonneBDPriseEnCompte(iIndiceColonne)
            if colonneDonnees is not None:

                sNomColonne = str(colonneDonnees.m_sNomColonne)
                #if the position of this column is not no where
                if self.__m_contexteResolution.ObtenirTypePrisEnCompteAttribut(sNomColonne) != ResolutionContext.PRISE_EN_COMPTE_ITEM_NULLE_PART:

                    # Attributs qualitatifs :
                    if colonneDonnees.m_iTypeValeurs == DatabaseAdmin.TYPE_VALEURS_COLONNE_ITEM:

                        # Items :
                        tItems = colonneDonnees.ConstituerTableauValeurs()
                        if tItems is not None:
                            iIndiceItem = 0
                            while iIndiceItem<len(tItems):
                                if self.__m_contexteResolution.ObtenirTypePrisEnCompteItem(sNomColonne, tItems[iIndiceItem]) != ResolutionContext.PRISE_EN_COMPTE_ITEM_NULLE_PART:
                                    self.__m_contexteResolution.DefinirTypePrisEnCompteItem_Filtrage(sNomColonne, tItems[iIndiceItem], ResolutionContext.PRISE_EN_COMPTE_ITEM_2_COTES)
                                    self.__m_contexteResolution.DefinirPresenceObligatoireItem_Filtrage(sNomColonne, tItems[iIndiceItem], False)
                                iIndiceItem += 1

                    # Attributs quantitatifs :
                    elif colonneDonnees.m_iTypeValeurs == DatabaseAdmin.TYPE_VALEURS_COLONNE_REEL:
                        self.__m_contexteResolution.DefinirTypePrisEnCompteAttribut_Filtrage(sNomColonne, ResolutionContext.PRISE_EN_COMPTE_ITEM_2_COTES)
                        self.__m_contexteResolution.DefinirPresenceObligatoireAttribut_Filtrage(sNomColonne, False)
            iIndiceColonne += 1


        # We treat the 2 sides of the ruler approximately the same way :
        for iIndiceCoteRegle in range(0, 2):

            if iIndiceCoteRegle==0:
                iNombreItems = regleCourante.m_iNombreItemsGauche
                tItemsRegle = regleCourante.m_tItemsGauche
                iTypePriseEnCompte = src.solver.ResolutionContext.PRISE_EN_COMPTE_ITEM_GAUCHE
            else:
                iNombreItems = regleCourante.m_iNombreItemsDroite
                tItemsRegle = regleCourante.m_tItemsDroite
                iTypePriseEnCompte = src.solver.ResolutionContext.PRISE_EN_COMPTE_ITEM_DROITE


            iIndiceItem = 0
            while iIndiceItem<iNombreItems:
                item = tItemsRegle[iIndiceItem]

                if item.m_iTypeItem == Item.ITEM_TYPE_QUALITATIF:
                    itemQual = item
                    sNomColonne = itemQual.m_attributQual.ObtenirNom()
                    sNomItem = itemQual.ObtenirIdentifiantTexteItem()

                    self.__m_contexteResolution.DefinirTypePrisEnCompteItem_Filtrage(sNomColonne, sNomItem, iTypePriseEnCompte)
                    self.__m_contexteResolution.DefinirPresenceObligatoireItem_Filtrage(sNomColonne, sNomItem, True)
                elif item.m_iTypeItem == Item.ITEM_TYPE_QUANTITATIF:
                    itemQuant = item
                    sNomColonne = itemQuant.m_attributQuant.ObtenirNom()

                    self.__m_contexteResolution.DefinirTypePrisEnCompteAttribut_Filtrage(sNomColonne, iTypePriseEnCompte)
                    self.__m_contexteResolution.DefinirPresenceObligatoireAttribut_Filtrage(sNomColonne, True)
                iIndiceItem += 1


        # Pour ce type de filtrage, un tri croissant par nombre d'attributs est la m�thode la mieux adapt�e :
        self.__jComboBoxMethodeTri.setSelectedIndex(2)
        self.__jCheckBoxTriDecroissant.setSelected(False)

        # Rafra�chissement :
        self.__jScrollPaneFiltre.repaint()
        self.__m_panneauResultats.MettreAJourListeRegles() #GEN-LAST:event_jButtonFiltreSelectionActionPerformed



    def __jButtonReinitFiltreActionPerformed(self, evt):
        iNombreColonnes = 0
        iIndiceColonne = 0
        iTypeNoeud = 0
        sNomColonne = None
        colonneDonnees = None
        gestionnaireBD = None
        tItems = None
        iIndiceItem = 0
        iTypePriseEnCompte = 0
        bPresenceObligatoire = False

        if self.__m_contexteResolution is None:
            return

        gestionnaireBD = self.__m_contexteResolution.m_gestionnaireBD
        if gestionnaireBD is None:
            return

        iNombreColonnes = gestionnaireBD.ObtenirNombreColonnesPrisesEnCompte()
        if iNombreColonnes == 0:
            return

        iIndiceColonne = 0
        while iIndiceColonne<iNombreColonnes:

            colonneDonnees = gestionnaireBD.ObtenirColonneBDPriseEnCompte(iIndiceColonne)
            if colonneDonnees is not None:

                sNomColonne = str(colonneDonnees.m_sNomColonne)

                iTypePriseEnCompte = self.__m_contexteResolution.ObtenirTypePrisEnCompteAttribut(sNomColonne)
                if iTypePriseEnCompte != ResolutionContext.PRISE_EN_COMPTE_ITEM_NULLE_PART:

                    self.__m_contexteResolution.DefinirTypePrisEnCompteAttribut_Filtrage(sNomColonne, iTypePriseEnCompte)

                    # Attributs qualitatifs :
                    if colonneDonnees.m_iTypeValeurs == DatabaseAdmin.TYPE_VALEURS_COLONNE_ITEM:

                        # Items :
                        tItems = colonneDonnees.ConstituerTableauValeurs()
                        if tItems is not None:
                            iIndiceItem = 0
                            while iIndiceItem<len(tItems):

                                iTypePriseEnCompte = self.__m_contexteResolution.ObtenirTypePrisEnCompteItem(sNomColonne, tItems[iIndiceItem])
                                if iTypePriseEnCompte != ResolutionContext.PRISE_EN_COMPTE_ITEM_NULLE_PART:
                                    self.__m_contexteResolution.DefinirTypePrisEnCompteItem_Filtrage(sNomColonne, tItems[iIndiceItem], iTypePriseEnCompte)

                                    bPresenceObligatoire = self.__m_contexteResolution.ObtenirPresenceObligatoireItem(sNomColonne, tItems[iIndiceItem])
                                    self.__m_contexteResolution.DefinirPresenceObligatoireItem_Filtrage(sNomColonne, tItems[iIndiceItem], bPresenceObligatoire)
                                iIndiceItem += 1

                    # Attributs quantitatifs :
                    elif colonneDonnees.m_iTypeValeurs == DatabaseAdmin.TYPE_VALEURS_COLONNE_REEL:

                        bPresenceObligatoire = (self.__m_contexteResolution.ObtenirPresenceObligatoireAttribut(sNomColonne) == 1)
                        self.__m_contexteResolution.DefinirPresenceObligatoireAttribut_Filtrage(sNomColonne, bPresenceObligatoire)

            iIndiceColonne += 1

        self.__jScrollPaneFiltre.repaint()
        self.__m_panneauResultats.MettreAJourListeRegles() #GEN-LAST:event_jButtonReinitFiltreActionPerformed



    def __jButtonAppliquerActionPerformed(self, evt):
        self.__m_panneauResultats.MettreAJourListeRegles() #GEN-LAST:event_jButtonAppliquerActionPerformed



    def __jButtonFiltreActionPerformed(self, evt):
        self.__m_bPanneauFiltreAffiche = not self.__m_bPanneauFiltreAffiche

        if self.__m_bPanneauFiltreAffiche:
            self.__jButtonFiltre.setText("Hide filter")
        else:
            self.__jButtonFiltre.setText("Display filter")

        self.__jScrollPaneFiltre.setVisible(self.__m_bPanneauFiltreAffiche)
        self.__m_panneauResultats.IndiquerModificationAffichageFiltre() #GEN-LAST:event_jButtonFiltreActionPerformed



    # Variables declaration - do not modify//GEN-BEGIN:variables
    # End of variables declaration//GEN-END:variables



    def ObtenirTailleReduite(self):
        iTailleReduite = 0

        iTailleReduite = self.__jButtonFiltre.getY()
        iTailleReduite += self.__jButtonFiltre.getHeight()
        iTailleReduite = math.trunc(iTailleReduite / float(2)) + self.__jLabelFiltre.getY()/2

        return iTailleReduite



    def EstFiltreAffiche(self):
        return self.__m_bPanneauFiltreAffiche



    def ObtenirMethodeTri(self):
        if self.__jComboBoxMethodeTri.getSelectedIndex() == 0:
            return METHODE_TRI_CONFIANCE
        if (self.__jComboBoxMethodeTri.getSelectedIndex() == 0) or (self.__jComboBoxMethodeTri.getSelectedIndex() == 1):
            return METHODE_TRI_SUPPORT
        if (self.__jComboBoxMethodeTri.getSelectedIndex() == 0) or (self.__jComboBoxMethodeTri.getSelectedIndex() == 1) or (self.__jComboBoxMethodeTri.getSelectedIndex() == 2):
            return METHODE_TRI_NOMBRE_ATTRIBUTS

        if True:
            return METHODE_TRI_CONFIANCE



    def EstTriDecroissant(self):
        return (self.__jCheckBoxTriDecroissant.isSelected())



    # Renvoie la valeur du sueil maximum de support du cons�quent sp�cifi� dans le filtrage d'int�r�t des
    # r�gles, ou -1.0f si celui-ci n'est pas d�fini :
    def ObtenirSueilMaxSupportConsequent(self):
        fSeuilSupportMax = 0.0f

        if self.__jCheckBoxInteret.isSelected():
            try:
                fSeuilSupportMax = float((float(self.__jTextFieldInteret.getText()) / 100.0))
            except NumberFormatException as e:
                fSeuilSupportMax = -1.0f
        else:
            fSeuilSupportMax = -1.0f

        return fSeuilSupportMax



    def ArrangerDisposition(self):
        self.__jButtonAppliquer.setLocation(self.getWidth()-self.__jButtonAppliquer.getWidth()-10, self.__jButtonAppliquer.getY())

        self.__jScrollPaneFiltre.setBounds(self.__jScrollPaneFiltre.getX(), self.__jScrollPaneFiltre.getY(), self.getWidth() - 2*self.__jScrollPaneFiltre.getX(), self.getHeight() - self.__jScrollPaneFiltre.getY() - 10)



    def __InitialiserContenuPanneau(self):
        iNombreColonnes = 0
        iIndiceColonne = 0
        iTypeNoeud = 0
        sNomColonne = None
        attributsBD = None
        treeTable = None
        gestionnaireBD = None
        colonneDonnees = None
        tItems = None
        tOccurrences = None
        iPasseRemplissage = 0
        noeudRacine = None
        noeudCourant = None
        sDescriptionElement = None
        iNombreRegles = 0
        iIndiceRegle = 0
        iIndiceCoteRegle = 0
        iNombreItems = 0
        iIndiceItem = 0
        item = None
        tItemsRegle = None
        itemQual = None
        itemQuant = None
        regle = None
        tableOccurrencesAttributs = None
        tableAttributsQualitatifs = None
        tableOccurrencesItems = None



        if self.__m_contexteResolution is None:
            return

        gestionnaireBD = self.__m_contexteResolution.m_gestionnaireBD
        if gestionnaireBD is None:
            return

        iNombreColonnes = gestionnaireBD.ObtenirNombreColonnesPrisesEnCompte()
        if iNombreColonnes == 0:
            return



        #----------------------------------------------------------------------------------------
        # On commence par comptabiliser les occurrences de chaque attribut/item dans les r�gles :


        # D�finition d'une classe permettant de m�moriser les 2 nombres d'occurrences par attribut/item :

#        class NombreOccurrences
        #        {
        #
        #            public int m_iOccurrencesGauche = 0
        #            public int m_iOccurrencesDroite = 0
        #
        #            public NombreOccurrences()
        #            {
        #                m_iOccurrencesGauche = 0
        #                m_iOccurrencesDroite = 0
        #            }
        #        }
        nombreOccurrencesAttribut = None
        nombreOccurrencesItem = None


        # Cr�ation des structures de donn�es visant � m�moriser les nombres d'occurrences :

        tableOccurrencesAttributs = {}
        tableAttributsQualitatifs = {}
        tableOccurrencesItems = {}


        # Instanciation des structures de donn�es :

        iIndiceColonne = 0
        while iIndiceColonne<iNombreColonnes:

            colonneDonnees = gestionnaireBD.ObtenirColonneBDPriseEnCompte(iIndiceColonne)
            if colonneDonnees.m_sNomColonne is not None:
                sNomColonne = str(colonneDonnees.m_sNomColonne)

                # Il n'est pas utile de prendre en consid�ration les attributs qui ne devaient pas appara�tre dans les r�gles :
                if self.__m_contexteResolution.ObtenirTypePrisEnCompteAttribut(sNomColonne) != ResolutionContext.PRISE_EN_COMPTE_ITEM_NULLE_PART:

                    tableOccurrencesAttributs.update({sNomColonne: NombreOccurrences()})

                    # Cas particulier des attributs qualitatifs o� on doit cr�er une structure pour chaque item :
                    if colonneDonnees.m_iTypeValeurs == DatabaseAdmin.TYPE_VALEURS_COLONNE_ITEM:

                        # Cr�ation de la sous-table de hachage destin�e � r�pertorier chaque item de l'attribut :
                        tableOccurrencesItems = {}
                        tableAttributsQualitatifs.update({sNomColonne: tableOccurrencesItems})

                        tItems = colonneDonnees.ConstituerTableauValeurs()
                        iIndiceItem = 0
                        while iIndiceItem<len(tItems):
                            if tItems[iIndiceItem] is not None:
                                if self.__m_contexteResolution.ObtenirTypePrisEnCompteItem(sNomColonne, tItems[iIndiceItem]) != ResolutionContext.PRISE_EN_COMPTE_ITEM_NULLE_PART:
                                    tableOccurrencesItems.update({tItems[iIndiceItem]: NombreOccurrences()})
                            iIndiceItem += 1

            iIndiceColonne += 1


        # Calcul des nombres d'occurrences :

        if self.__m_contexteResolution.m_listeRegles is not None:
            iNombreRegles = len(self.__m_contexteResolution.m_listeRegles)
        else:
            iNombreRegles = 0


        iIndiceRegle = 0
        while iIndiceRegle<iNombreRegles:
            regle = self.__m_contexteResolution.m_listeRegles[iIndiceRegle]

            # On traite les 2 c�t�s de la r�gle approximativemen de la m�me mani�re :
            for iIndiceCoteRegle in range(0, 2):

                if iIndiceCoteRegle==0:
                    iNombreItems = regle.m_iNombreItemsGauche
                    tItemsRegle = regle.m_tItemsGauche
                else:
                    iNombreItems = regle.m_iNombreItemsDroite
                    tItemsRegle = regle.m_tItemsDroite

                iIndiceItem = 0
                while iIndiceItem<iNombreItems:
                    item = tItemsRegle[iIndiceItem]
                    if item.m_iTypeItem == Item.ITEM_TYPE_QUALITATIF:
                        itemQual = item

                        # On r�cup�re les nombres courants d'occurrences pour l'attribut :
                        nombreOccurrencesAttribut = tableOccurrencesAttributs[itemQual.m_attributQual.ObtenirNom()]

                        # On r�cup�re les nombres courants d'occurrences pour l'item :
                        tableOccurrencesItems = tableAttributsQualitatifs[itemQual.m_attributQual.ObtenirNom()]
                        if tableOccurrencesItems is not None:
                            nombreOccurrencesItem = tableOccurrencesItems[itemQual.ObtenirIdentifiantTexteItem()]
                        else:
                            nombreOccurrencesItem = None

                        # Incr�mentation du bon c�t� de la r�gle :
                        if iIndiceCoteRegle==0:
                            if nombreOccurrencesAttribut is not None:
                                nombreOccurrencesAttribut.m_iOccurrencesGauche += 1
                            if nombreOccurrencesItem is not None:
                                nombreOccurrencesItem.m_iOccurrencesGauche += 1
                        else:
                            if nombreOccurrencesAttribut is not None:
                                nombreOccurrencesAttribut.m_iOccurrencesDroite += 1
                            if nombreOccurrencesItem is not None:
                                nombreOccurrencesItem.m_iOccurrencesDroite += 1

                    elif item.m_iTypeItem == Item.ITEM_TYPE_QUANTITATIF:
                        itemQuant = item

                        # On r�cup�re les nombres courants d'occurrences pour l'attribut :
                        nombreOccurrencesAttribut = tableOccurrencesAttributs[itemQuant.m_attributQuant.ObtenirNom()]

                        # Incr�mentation du bon c�t� de la r�gle :
                        if nombreOccurrencesAttribut is not None:
                            if iIndiceCoteRegle==0:
                                nombreOccurrencesAttribut.m_iOccurrencesGauche += 1
                            else:
                                nombreOccurrencesAttribut.m_iOccurrencesDroite += 1
                    iIndiceItem += 1
            iIndiceRegle += 1



        #-------------------------------------
        # Remplissage du tableau de filtrage :

        attributsBD = AttributsBDModel()
        noeudRacine = attributsBD.getRoot()


        # Remplissage de la liste des noms de colonnes qualitatives puis quantitatives disponibles au total dans la BD :    
        for iPasseRemplissage in range(0, 2):
            iIndiceColonne = 0
            while iIndiceColonne<iNombreColonnes:

                colonneDonnees = gestionnaireBD.ObtenirColonneBDPriseEnCompte(iIndiceColonne)
                if colonneDonnees is not None:
                    if ((iPasseRemplissage==0) and (colonneDonnees.m_iTypeValeurs == DatabaseAdmin.TYPE_VALEURS_COLONNE_ITEM)) or ((iPasseRemplissage==1) and (colonneDonnees.m_iTypeValeurs == DatabaseAdmin.TYPE_VALEURS_COLONNE_REEL)):

                        sNomColonne = str(colonneDonnees.m_sNomColonne)
                        if self.__m_contexteResolution.ObtenirTypePrisEnCompteAttribut(sNomColonne) != ResolutionContext.PRISE_EN_COMPTE_ITEM_NULLE_PART:

                            # Construction de la phrase de description :
                            nombreOccurrencesAttribut = tableOccurrencesAttributs[sNomColonne]
                            if nombreOccurrencesAttribut is not None:
                                sDescriptionElement = " " + String.valueOf(nombreOccurrencesAttribut.m_iOccurrencesGauche) + "  left,  " + String.valueOf(nombreOccurrencesAttribut.m_iOccurrencesDroite) + "  right,  " + String.valueOf(nombreOccurrencesAttribut.m_iOccurrencesGauche+nombreOccurrencesAttribut.m_iOccurrencesDroite) + "  in total."
                            else:
                                sDescriptionElement = "Error of comptabilisation !"

                            # Attributs qualitatifs :
                            if colonneDonnees.m_iTypeValeurs == DatabaseAdmin.TYPE_VALEURS_COLONNE_ITEM:

                                iTypeNoeud = AttributsBDModel.ELEMENT_MODEL_ATTRIBUT_QUAL

                                noeudCourant = attributsBD.AjouterNoeud(noeudRacine, AttributsBDModel.AttributBDDescription(sNomColonne, iTypeNoeud, sDescriptionElement, self.__m_contexteResolution.ObtenirInfosPostionnementFiltrage(), False))

                                # On r�cup�re la table des nombres d'occurrences des items de l'attribut :
                                tableOccurrencesItems = tableAttributsQualitatifs[sNomColonne]

                                # On fait figurer dans la sous-arborescence chacunes des valeurs :
                                tItems = colonneDonnees.ConstituerTableauValeurs()
                                if tItems is not None:

                                    # Constitution du tableau r�pertoriant les occurrences (dans la BD) pour chaque item :
                                    tOccurrences = [0 for _ in range(len(tItems))]
                                iIndiceItem = 0
                                while iIndiceItem<len(tItems):
                                    tOccurrences[iIndiceItem] = colonneDonnees.ObtenirNombreOccurrencesItem(tItems[iIndiceItem])
                                    iIndiceItem += 1

                                # Tri des items par occurrences :
                                tItems = SortingTools.CompateurBiTableaux_Chaines_Entiers(tItems, tOccurrences, False)

                                iIndiceItem = 0
                                while iIndiceItem<len(tItems):
                                    if self.__m_contexteResolution.ObtenirTypePrisEnCompteItem(sNomColonne, tItems[iIndiceItem]) != ResolutionContext.PRISE_EN_COMPTE_ITEM_NULLE_PART:

                                        # Construction de la phrase de description :
                                        sDescriptionElement = "Error of comptabilisation !"
                                        if tableOccurrencesItems is not None:
                                            nombreOccurrencesItem = tableOccurrencesItems[tItems[iIndiceItem]]
                                            if nombreOccurrencesItem is not None:
                                                sDescriptionElement = " " + String.valueOf(nombreOccurrencesItem.m_iOccurrencesGauche) + "  left,  " + String.valueOf(nombreOccurrencesItem.m_iOccurrencesDroite) + "  right,  " + String.valueOf(nombreOccurrencesItem.m_iOccurrencesGauche+nombreOccurrencesItem.m_iOccurrencesDroite) + "  in total."

                                        attributsBD.AjouterNoeud(noeudCourant, AttributsBDModel.AttributBDDescription(sNomColonne, tItems[iIndiceItem], sDescriptionElement, self.__m_contexteResolution.ObtenirInfosPostionnementFiltrage(), False))
                                    iIndiceItem += 1

                            # Attributs quantitatifs :
                            elif colonneDonnees.m_iTypeValeurs == DatabaseAdmin.TYPE_VALEURS_COLONNE_REEL:

                                iTypeNoeud = AttributsBDModel.ELEMENT_MODEL_ATTRIBUT_QUANT
                                attributsBD.AjouterNoeud(noeudRacine, AttributsBDModel.AttributBDDescription(sNomColonne, iTypeNoeud, sDescriptionElement, self.__m_contexteResolution.ObtenirInfosPostionnementFiltrage(), False))

                iIndiceColonne += 1


        tableOccurrencesItems.clear()
        tableAttributsQualitatifs.clear()
        tableOccurrencesAttributs.clear()

        attributsBD.ModifierNomColonne(1, "Apparitions dans les rules :")

        treeTable = JTreeTable(attributsBD)

        # Ajout � posteriori de certaines sp�cificit�s � la table :
        attributsBD.AdapterTreeTableAModele(treeTable)

        self.__jScrollPaneFiltre.setViewportView(treeTable)
        self.__jScrollPaneFiltre.validate()


