import math

#                                             
# *Copyright 2007, 2011 CCLS Columbia University (USA), LIFO University of Orl��ans (France), BRGM (France)
# *
# *Authors: Cyril Nortet, Xiangrong Kong, Ansaf Salleb-Aouissi, Christel Vrain, Daniel Cassard
# *
# *This file is part of QuantMiner.
# *
# *QuantMiner is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.
# *
# *QuantMiner is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
# *
# *You should have received a copy of the GNU General Public License along with QuantMiner.  If not, see <http://www.gnu.org/licenses/>.
# 
import sys
import os

cwd = os.getcwd()
sys.path.append(cwd)
# sys.path.append('C:\\Users\\aalsahee\\python_physical_model\\Saudi\\trace\\Traces\\qtm\\src\\')

# from apriori import AttributQualitative
# from apriori import AttributQuantitative
from apriori_solver.onefile import *
from graphicalInterface.DatabasePanelAssistant import *
from database.onefile import DataColumn
from database.onefile import DatabaseAdmin
# from solver import *
from tools import *
from graphicalInterface.PanelQuantitativeRuleParam import *
from graphicalInterface.PanelRuleParam import *
# from geneticAlgorithm import *
from graphicalInterface.PanelGeneticParam import *


# Identification des zones o� int�grer des panneaux de choose parameter du proc�d� d'extraction :
CONTENEUR_PARAM_REGLES = 1 #rules parameter
CONTENEUR_PARAM_TECH = 2 #technique parameter

# Identification des different panneaux de param�trage des r�gles � extraire :
PANNEAU_PARAM_REGLES_AUCUN = 0
PANNEAU_PARAM_REGLES_STANDARD = 1
PANNEAU_PARAM_REGLES_QUANTITATIVES_STANDARD = 2

# Identification des different panneaux de param�trage des techniques d'extraction :
PANNEAU_PARAM_TECH_SANS_CONFIGURATION = 1
PANNEAU_PARAM_TECH_GENETIQUE = 2
PANNEAU_PARAM_TECH_RECUIT = 3
PANNEAU_PARAM_TECH_CHARGEMENT = 4

# class PanelTechnConfig:
class PanelTechnConfig(DatabasePanelAssistant):

    #Two panels, technique panel and rule panel


    #* Creates new form PanneauConfigTechnique 
    def __init__(self, contexteResolution):
        self.m_panneauParamsRegles = None
        self.m_panneauParamsTech = None
        self.__jButtonInfoTechnique = None
        self.__jComboTechnique = None
        self.__jLabelTechnique = None
        self.__jScrollPaneParamRegles = None
        self.__jScrollPaneParamTech = None

        super().__init__(contexteResolution)

        self.m_panneauParamsRegles = None
        self.m_panneauParamsTech = None

        # self.__initComponents()

        # super().DefinirEtape(3, "Parameters configuration", ENV.REPERTOIRE_AIDE+"technical_setting.htm")
        # super().DefinirPanneauPrecedent(MainWindow.PANNEAU_PRE_EXTRACION) #previous step is step2
        # super().DefinirPanneauSuivant(MainWindow.PANNEAU_TECH_GENERIQUE) #next step is step4
        # super().initBaseComponents()
        # self.ArrangerDisposition()


        if self.m_contexteResolution.m_iTechniqueResolution == ResolutionContext.TECHNIQUE_APRIORI_QUAL:
            self.ActiverPanneauAssistant1(ResolutionContext.TECHNIQUE_APRIORI_QUAL)

        elif self.m_contexteResolution.m_iTechniqueResolution == ResolutionContext.TECHNIQUE_ALGO_GENETIQUE:
            self.ActiverPanneauAssistant1(ResolutionContext.TECHNIQUE_ALGO_GENETIQUE)

        elif self.m_contexteResolution.m_iTechniqueResolution == ResolutionContext.TECHNIQUE_RECUIT_SIMULE:
            self.ActiverPanneauAssistant1(ResolutionContext.TECHNIQUE_RECUIT_SIMULE)

        elif self.m_contexteResolution.m_iTechniqueResolution == ResolutionContext.TECHNIQUE_CHARGEMENT:
            self.ActiverPanneauAssistant1(ResolutionContext.TECHNIQUE_CHARGEMENT)

        else:
            return



    #    * This method is called from within the constructor to
    #     * initialize the form.
    #     * WARNING: Do NOT modify this code. The content of this method is
    #     * always regenerated by the Form Editor.
    #     
    # <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    # def __initComponents(self):
    #     self.__jComboTechnique = javax.swing.JComboBox()
    #     self.__jButtonInfoTechnique = javax.swing.JButton()
    #     self.__jLabelTechnique = javax.swing.JLabel()
    #     self.__jScrollPaneParamRegles = javax.swing.JScrollPane() #rule scroll panel
    #     self.__jScrollPaneParamTech = javax.swing.JScrollPane() #technical rule scroll panel

    #     setLayout(None)

    #     #Start of ComboBox of Technique selection
    #     self.__jComboTechnique.setModel(javax.swing.DefaultComboBoxModel(["Standard Apriori", "Genetic algorithm", "Simulated annealing", "Load a set of precomputed rules"]))
    #     self.__jComboTechnique.addActionListener(ActionListenerAnonymousInnerClass(self))

    #     add(self.__jComboTechnique)
    #     self.__jComboTechnique.setBounds(170, 20, 390, 30)
    #     #End of ComboBox of Technique selection

    #     #Start of the help button next to ComboBox
    #     self.__jButtonInfoTechnique.setText("?")
    #     self.__jButtonInfoTechnique.addActionListener(ActionListenerAnonymousInnerClass2(self))

    #     add(self.__jButtonInfoTechnique)
    #     self.__jButtonInfoTechnique.setBounds(570, 20, 50, 30)
    #     #End of the help button next to ComboBox

    #     #Start of the label of the technique selection
    #     self.__jLabelTechnique.setText("Technique:")
    #     add(self.__jLabelTechnique)
    #     self.__jLabelTechnique.setBounds(20, 20, 140, 30)
    #     #End of the label of the technique selection

    #     #Start of rules parameter selection panel
    #     self.__jScrollPaneParamRegles.setBorder(javax.swing.BorderFactory.createTitledBorder(None, "Rule parameters", javax.swing.border.TitledBorder.LEFT, javax.swing.border.TitledBorder.TOP, java.awt.Font("Dialog", 3, 14)))
    #     add(self.__jScrollPaneParamRegles)
    #     self.__jScrollPaneParamRegles.setBounds(20, 100, 600, 90)
    #     #End of rules parameter selection panel

    #     #Start of technical parameter selection panel
    #     self.__jScrollPaneParamTech.setBorder(javax.swing.BorderFactory.createTitledBorder(None, "Technique parameters", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, java.awt.Font("Dialog", 3, 14)))
    #     add(self.__jScrollPaneParamTech)
    #     self.__jScrollPaneParamTech.setBounds(20, 230, 600, 120)
        #End of technical parameter selection panel
 # </editor-fold>//GEN-END:initComponents

    # class ActionListenerAnonymousInnerClass(java.awt.event.ActionListener):

    #     def __init__(self, outerInstance):
    #         self.__outerInstance = outerInstance

    #     def actionPerformed(self, evt):
    #         outerInstance.__jComboTechniqueActionPerformed(evt)

    # class ActionListenerAnonymousInnerClass2(java.awt.event.ActionListener):

    #     def __init__(self, outerInstance):
    #         self.__outerInstance = outerInstance

    #     def actionPerformed(self, evt):
    #         outerInstance.__jButtonInfoTechniqueActionPerformed(evt)


    def __jComboTechniqueActionPerformed(self, evt):
        sTechniqueSelectionnee = None #the name of the selected item
        iTechniqueSelectionnee = ResolutionContext.TECHNIQUE_INDEFINIE #at the beginning, technique is undefined
        bSuiteAutorisee = False

        sTechniqueSelectionnee = str((evt.getSource()).getSelectedItem())
        if sTechniqueSelectionnee is not None:
            if sTechniqueSelectionnee == "Standard Apriori":
                iTechniqueSelectionnee = ResolutionContext.TECHNIQUE_APRIORI_QUAL
            elif sTechniqueSelectionnee == "Genetic algorithm":
                iTechniqueSelectionnee = ResolutionContext.TECHNIQUE_ALGO_GENETIQUE
            elif sTechniqueSelectionnee == "Simulated annealing":
                iTechniqueSelectionnee = ResolutionContext.TECHNIQUE_RECUIT_SIMULE
            elif sTechniqueSelectionnee == "Load a set of precomputed rules": #("Chargement d'un fichier de r�gles pr�-calcul�es"))
                iTechniqueSelectionnee = ResolutionContext.TECHNIQUE_CHARGEMENT

        if iTechniqueSelectionnee != ResolutionContext.TECHNIQUE_INDEFINIE:
            bSuiteAutorisee = True

            if self.m_panneauParamsRegles is not None:
                bSuiteAutorisee = bSuiteAutorisee and self.m_panneauParamsRegles.EnregistrerParametres()

            if bSuiteAutorisee and (m_panneauParamsTech is not None):
                bSuiteAutorisee = bSuiteAutorisee and self.m_panneauParamsTech.EnregistrerParametres()

            if bSuiteAutorisee:
                self.ActiverPanneauAssistant(iTechniqueSelectionnee) #GEN-LAST:event_jComboTechniqueActionPerformed


    def __jButtonInfoTechniqueActionPerformed(self, evt):
        dialogAide = None
        sNomFichierAide = None

        if self.m_contexteResolution.m_iTechniqueResolution == ResolutionContext.TECHNIQUE_APRIORI_QUAL:
            sNomFichierAide = "apriori_english.htm"
        elif self.m_contexteResolution.m_iTechniqueResolution == ResolutionContext.TECHNIQUE_ALGO_GENETIQUE:
            sNomFichierAide = "genetic_algorithm.htm"
        elif self.m_contexteResolution.m_iTechniqueResolution == ResolutionContext.TECHNIQUE_RECUIT_SIMULE:
            sNomFichierAide = "simulated_annealing.htm"
        elif self.m_contexteResolution.m_iTechniqueResolution == ResolutionContext.TECHNIQUE_CHARGEMENT:
            sNomFichierAide = "rules_loading.htm"

        if sNomFichierAide is not None:
            dialogAide = DialogHelp(ENV.REPERTOIRE_AIDE+sNomFichierAide, None, True)
            dialogAide.show() #GEN-LAST:event_jButtonInfoTechniqueActionPerformed


    # Variables declaration - do not modify//GEN-BEGIN:variables
    # End of variables declaration//GEN-END:variables



    def ActiverPanneauAssistant1(self, iTechnique):
            # Technique, the chosen algorithm:
        if iTechnique == ResolutionContext.TECHNIQUE_ALGO_GENETIQUE:
            self.m_contexteResolution.m_iTechniqueResolution = ResolutionContext.TECHNIQUE_ALGO_GENETIQUE
            self.ActiverPanneauAssistant2(CONTENEUR_PARAM_REGLES, PANNEAU_PARAM_REGLES_QUANTITATIVES_STANDARD)
            self.ActiverPanneauAssistant2(CONTENEUR_PARAM_TECH, PANNEAU_PARAM_TECH_GENETIQUE)

            # Technique simulated annealing
        elif iTechnique == ResolutionContext.TECHNIQUE_RECUIT_SIMULE:
            self.m_contexteResolution.m_iTechniqueResolution = ResolutionContext.TECHNIQUE_RECUIT_SIMULE
            self.ActiverPanneauAssistant2(CONTENEUR_PARAM_REGLES, PANNEAU_PARAM_REGLES_QUANTITATIVES_STANDARD)
            self.ActiverPanneauAssistant2(CONTENEUR_PARAM_TECH, PANNEAU_PARAM_TECH_RECUIT)

            #Load a set of precomputed rules
        elif iTechnique == ResolutionContext.TECHNIQUE_CHARGEMENT:
            self.m_contexteResolution.m_iTechniqueResolution = ResolutionContext.TECHNIQUE_CHARGEMENT
            self.ActiverPanneauAssistant2(CONTENEUR_PARAM_REGLES, PANNEAU_PARAM_REGLES_AUCUN)
            self.ActiverPanneauAssistant2(CONTENEUR_PARAM_TECH, PANNEAU_PARAM_TECH_CHARGEMENT)

            # By default, it is Apriori standard(i think it is for itemset, i.e. categorical)(qualitatif uniquement) :
        else:
            self.m_contexteResolution.m_iTechniqueResolution = ResolutionContext.TECHNIQUE_APRIORI_QUAL
            self.ActiverPanneauAssistant2(CONTENEUR_PARAM_REGLES, PANNEAU_PARAM_REGLES_STANDARD)
            self.ActiverPanneauAssistant2(CONTENEUR_PARAM_TECH, PANNEAU_PARAM_TECH_SANS_CONFIGURATION)

        # self.DisposerPanneauxParams()
        # self.__jScrollPaneParamRegles.validate()
        # self.__jScrollPaneParamTech.validate()



    def ActiverPanneauAssistant2(self, iConteneur, iPanneau):

        panneauAncien = None
        panneauActive = None
        conteneur = None


        # Dis-activate the existing panel

        if iConteneur==CONTENEUR_PARAM_REGLES:
            panneauAncien = self.m_panneauParamsRegles
        elif iConteneur==CONTENEUR_PARAM_TECH:
            panneauAncien = self.m_panneauParamsTech

        if panneauAncien is not None:
            panneauAncien.setVisible(False)
            panneauAncien = None


        # Active the specific panel:

        if iConteneur == CONTENEUR_PARAM_REGLES:


            if iPanneau == PANNEAU_PARAM_REGLES_AUCUN: #no panel to display
                panneauActive = None


            elif iPanneau == PANNEAU_PARAM_REGLES_STANDARD: #show standard rule parameter panel
                panneauActive = (PanelRuleParam(self.m_contexteResolution))


            elif iPanneau == PANNEAU_PARAM_REGLES_QUANTITATIVES_STANDARD: #show quantitative standard rule parameter panel
                panneauActive = (PanelQuantitativeRuleParam(self.m_contexteResolution))


            self.m_panneauParamsRegles = panneauActive

        elif iConteneur==CONTENEUR_PARAM_TECH:


            if iPanneau == PANNEAU_PARAM_TECH_SANS_CONFIGURATION:
                panneauActive = None

            elif iPanneau == PANNEAU_PARAM_TECH_GENETIQUE: #generic algorithm
                panneauActive = (PanelGeneticParam(self.m_contexteResolution))

            elif iPanneau == PANNEAU_PARAM_TECH_RECUIT: #simulated annealing algorithm
                panneauActive = (PanelSimulatedParam(self.m_contexteResolution))

            elif iPanneau == PANNEAU_PARAM_TECH_CHARGEMENT: #load a precomputed rule file
                panneauActive = (PanelParamLoading(self.m_contexteResolution))


            self.m_panneauParamsTech = panneauActive


        # Inclusion du panneau dans son conteneur ad�quat :

        conteneur = None
        if iConteneur==CONTENEUR_PARAM_REGLES: #if it is rule parameter panel
            conteneur = self.__jScrollPaneParamRegles
        elif iConteneur==CONTENEUR_PARAM_TECH: #if it is technique parameter panel
            conteneur = self.__jScrollPaneParamTech

        if conteneur is not None:
            if panneauActive is None:
                conteneur.setViewportView(JPanel())
                conteneur.setVisible(False)
            else:
                conteneur.setViewportView(panneauActive)
                conteneur.setVisible(True)



    # Outrepassement de la m�thode m�re pour l'ajustement des champs :
    def ArrangerDisposition(self):
        super().ArrangerDisposition()

        self.__jLabelTechnique.setLocation(self.__jLabelTechnique.getX(), self.m_zoneControles.y)
        self.__jComboTechnique.setLocation(self.__jComboTechnique.getX(), self.m_zoneControles.y)
        self.__jButtonInfoTechnique.setLocation(self.__jButtonInfoTechnique.getX(), self.m_zoneControles.y)

        self.DisposerPanneauxParams()


    # Dispose dans la fen�tre les 2 panneaux de configuration, de la meilleure mani�re possible :
    def DisposerPanneauxParams(self):
        iMaxHauteurParamRegles = 0
        iMaxHauteurParamTech = 0
        iMaxHauteurParams = 0
        iHauteurParamRegles = 0
        iHauteurParamTech = 0
        iCumulInsetsY = 0
        iPositionYParamTech = 0
        insets = None
        dimensionPanneau = None
        dimensionElement = None
        positionElement = None
        dimensionSupport = None # dimensions du panneau de support

        # iMaxHauteurParams = self.m_zoneControles.height - (self.__jLabelTechnique.getHeight() + 40)


        if self.m_panneauParamsTech is not None:
            iMaxHauteurParamRegles = math.trunc(iMaxHauteurParams / float(2))
        else:
            iMaxHauteurParamRegles = iMaxHauteurParams


        # Positionnement du panneau de configuration des r�gles :

        iHauteurParamRegles = 0
        if self.m_panneauParamsRegles is not None:

            insets = (self.__jScrollPaneParamRegles.getBorder()).getBorderInsets(self.__jScrollPaneParamRegles)
            iCumulInsetsY = insets.top + insets.bottom

            dimensionPanneau = self.m_panneauParamsRegles.getPreferredSize()
            if (dimensionPanneau.height+iCumulInsetsY) <= iMaxHauteurParamRegles:
                iHauteurParamRegles = dimensionPanneau.height + iCumulInsetsY
                self.__jScrollPaneParamRegles.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER)
            else:
                iHauteurParamRegles = iMaxHauteurParamRegles
                self.__jScrollPaneParamRegles.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS)

            self.__jScrollPaneParamRegles.setBounds(self.m_zoneControles.x, self.__jLabelTechnique.getY() + self.__jLabelTechnique.getHeight() + 20, self.m_zoneControles.width, iHauteurParamRegles)


        # Positionnement du panneau de configuration de la technique d'extraction :

        if self.m_panneauParamsRegles is not None:
            iMaxHauteurParamTech = iMaxHauteurParams - self.__jScrollPaneParamRegles.getHeight()
            iPositionYParamTech = self.__jScrollPaneParamRegles.getY() + self.__jScrollPaneParamRegles.getHeight() + 20
        else:
            iMaxHauteurParamTech = iMaxHauteurParams
            iPositionYParamTech = self.__jLabelTechnique.getY() + self.__jLabelTechnique.getHeight() + 20

        iHauteurParamTech = 0
        if self.m_panneauParamsTech is not None:

            insets = (self.__jScrollPaneParamRegles.getBorder()).getBorderInsets(self.__jScrollPaneParamTech)
            iCumulInsetsY = insets.top + insets.bottom

            dimensionPanneau = self.m_panneauParamsTech.getPreferredSize()
            if (dimensionPanneau.height+iCumulInsetsY) <= iMaxHauteurParamTech:
                iHauteurParamTech = dimensionPanneau.height + iCumulInsetsY
                self.__jScrollPaneParamTech.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER)
            else:
                iHauteurParamTech = iMaxHauteurParamTech
                self.__jScrollPaneParamTech.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS)

            self.__jScrollPaneParamTech.setBounds(self.m_zoneControles.x, iPositionYParamTech, self.m_zoneControles.width, iHauteurParamTech)



    # Outrepassement de la m�thode m�re pour mettre � jour les structures de donn�es 
    # suivant ce qui a �t� entr� dans les champs de contr�le :
    def SychroniserDonneesInternesSelonAffichage(self):
        bSuiteAutorisee = False

        # Enregistrement des param�tres utilisateur :

        bSuiteAutorisee = True

        if self.m_panneauParamsRegles is not None:
            bSuiteAutorisee = bSuiteAutorisee and self.m_panneauParamsRegles.EnregistrerParametres()

        if self.m_panneauParamsTech is not None:
            bSuiteAutorisee = bSuiteAutorisee and self.m_panneauParamsTech.EnregistrerParametres()

        return bSuiteAutorisee



    # Overriding the parent method for specific treatments:
    def TraitementsSpecifiquesAvantSuivant(self):
        bSuiteAutorisee = False
        sTechniqueSelectionnee = None
        iTechniqueSelectionnee = 0

        bSuiteAutorisee = super().TraitementsSpecifiquesAvantSuivant()

        if not bSuiteAutorisee:
            return False

        sTechniqueSelectionnee = str((self.__jComboTechnique.getSelectedItem()))
        if sTechniqueSelectionnee is None:
            return False

        if sTechniqueSelectionnee == "Standard Apriori":
            if self.getQuantitativeNumber() != 0:
                JOptionPane.showMessageDialog(None, "Cannot goto Step 4 with Standard Apriori, as one or more attributes are quantitative", "Error", JOptionPane.ERROR_MESSAGE)
                return False
            iTechniqueSelectionnee = ResolutionContext.TECHNIQUE_APRIORI_QUAL
            super().DefinirPanneauSuivant(MainWindow.PANNEAU_TECH_GENERIQUE)
        elif sTechniqueSelectionnee == "Genetic algorithm":
            iTechniqueSelectionnee = ResolutionContext.TECHNIQUE_ALGO_GENETIQUE
            super().DefinirPanneauSuivant(MainWindow.PANNEAU_TECH_GENERIQUE)
        elif sTechniqueSelectionnee == "Simulated annealing":
            iTechniqueSelectionnee = ResolutionContext.TECHNIQUE_RECUIT_SIMULE
            super().DefinirPanneauSuivant(MainWindow.PANNEAU_TECH_GENERIQUE)
        elif sTechniqueSelectionnee == "Load a set of precomputed rules":
            iTechniqueSelectionnee = ResolutionContext.TECHNIQUE_CHARGEMENT
            super().DefinirPanneauSuivant(MainWindow.PANNEAU_RESULTATS) #since you already have rules, just display the result
        else:
            return False

        return True

    def getQuantitativeNumber(self):
        colonneDonnees = None
        gestionnaireBD = self.m_contexteResolution.m_gestionnaireBD
        iNombreColonnes = 0
        iIndiceColonne = 0
        iTypePriseEnCompte = 0
        numQuantitave = 0
        iNombreColonnes = gestionnaireBD.ObtenirNombreColonnesPrisesEnCompte() #obtain the number of selected columns??

        iIndiceColonne = 0
        while iIndiceColonne < iNombreColonnes:
            colonneDonnees = gestionnaireBD.ObtenirColonneBDPriseEnCompte(iIndiceColonne)
            iTypePriseEnCompte = self.m_contexteResolution.ObtenirTypePrisEnCompteAttribut(colonneDonnees.m_sNomColonne)

            if colonneDonnees.m_iTypeValeurs == src.database.DatabaseAdmin.TYPE_VALEURS_COLONNE_REEL:
                if iTypePriseEnCompte != ResolutionContext.PRISE_EN_COMPTE_ITEM_NULLE_PART:
                    numQuantitave += 1

            iIndiceColonne += 1
        return numQuantitave

